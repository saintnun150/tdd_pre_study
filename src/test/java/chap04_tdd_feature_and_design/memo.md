# TDD 기능 명세 및 설계

## 기능 명세   

**기능을 구현할 때 입력, 결과**를 나눠 생각해볼 수 있다.   
예를 들어, 로그인 기능에서는 **아이디와 비밀번호**를 입력했을 때 그 결과에 따라 **성공** 또는 **실패**로 나눠진다.

### 만료일 계산 기능의 예시

3장에서 구현한 만료일 계산 기능의 입출력 결과는 다음과 같다.

 - **입력**: 첫 납부일, 납부일, 납부액
 - **출력**: 만료일
``` java
// parameter: 만료일 계산 기능의 입력(payData)
// return   : 만료일 계산 기능의 결과(localDate)

public LocalDate calculateExpiryDate(PayData payData) {
    int addToMonths = payData.getPayAmount() == 100_000 ? 12 : payData.getPayAmount() / 10_000;
    if (payData.getFirstBillingDate() != null) {
        return expiryDateUsingFirstBillingDate(payData, addToMonths);
    } else {
        return payData.getBillingDate().plusMonths(addToMonths);
    }
}
```

익셉션을 결과로 사용하는 것도 가능하다.
``` java
public void login(String id, String pw) {
    User user = getUser(id);
    if (!user.matchPasswd(pw)) {
        // 익셉션을 결과로 사용
        throw new IdPwNotMatchException();
    }
```

## 기능 실행 결과와 변경 사항
기능 실행 결과에는 **변경**도 포함된다.   
예를들어 회원 가입 기능은 실행 결과로 DB에 회원 정보를 추가한다.
DB에 데이터를 추가하는 것은 단순히 값을 리턴하는 것과 다르게 시스템의 상태를 변경하는 것이다.


이러한 변경은 리턴 값만으로는 기능이 정확한지 알 수 없기 때문에 DB에 접근하여 결과를 확인해야 한다.

또한 입력 데이터에 따라 **분기**하는 결과를 낳기도 한다.
동일한 ID가 존재할 경우 그 결과는 익셉션이고, 반대의 경우 회원 번호를 리턴하며 정보를 DB에 저장한다.

## 설계
설계는 기능 명세로부터 시작한다.   
TDD는 그 설계 과정을 지원한다.   
테스트 메서드는 **기능을 실행하고 결과를 검증**하는 데 목적이 있다.   
이를 위해 테스트 대상 기능이 **작성될 클래스와 메서드의 이름**을 정하고, **필요한 파라미터**를 정의하며, **결과값의 형태**를 결정한다.   
테스트 코드 작성 과정 자체가 **일부 설계**가 된다.

### 필요한 만큼 설계하기
TDD는 **테스트를 통과할 만큼만 코드를 작성**한다.   
앞으로 필요할 것으로 예측해서 미리 코드를 유연하게 만들지 않는다. 설계 역시 마찬가지이다.
실제 테스트 케이스를 추가하고 이를 검증하는 과정에서 필요한 만큼 설계를 변경해 나가야 한다.

## 구체화 과정

테스트 코드를 작성하는 개발자는 기능을 **명세화**하는 과정에서 담당자와 구체적인 논의를 해야 한다.   
예를 들어, 3장에서 **서비스 만료일을 계산**할 때, 다음과 같은 **구체적인 조건**을 명확히 해야 한다:

* 만 원을 납부했을 때 서비스 만료일이 납부한 날로부터 한 달 뒤라면, 그 만료일은 언제가 될 것인가?   
* 31일에 납부했을 때, 다음 달에 30일이 없을 경우는 어떻게 처리할 것인가?

이러한 모호한 상황에 대해 **기획자와 의논**하여 **구체적인 예시**를 정해야 한다.


